<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <!-- <meta name="viewport" content="width=device-width, initial-scale=1.0" /> -->
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>Hexamotive</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background: #1a1a2e;
        font-family: Arial, sans-serif;
      }
      canvas {
        display: block;
        /* cursor: grab; */
      }
      /* canvas:active {
        cursor: grabbing;
      } */
      #info {
        position: absolute;
        top: 10px;
        left: 10px;
        background: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 10px;
        border-radius: 5px;
        font-size: 14px;
      }
      .terrain-key {
        margin-top: 10px;
        font-size: 12px;
      }
      .terrain-item {
        display: flex;
        align-items: center;
        margin: 3px 0;
      }
      .terrain-color {
        width: 20px;
        height: 20px;
        margin-right: 8px;
        border: 1px solid #666;
      }
    </style>
  </head>
  <body>
<script src="chs.js"></script>
<script src="core.js"></script>
    <canvas id="hexCanvas"></canvas>

    <script type="module">
      import {checkMobileAndWarn} from "./utilities/mobileWarning.js"
      import {
        trackGameStarted,
        trackGameFinished,
        getUserID,
      } from "./utilities/analytics.js";
      import { welcomeScreen } from "./components/welcome.js";
      import {
        playBuildingSound,
        playRemovalSound,
      } from "./utilities/sounds.js";
      import { setHexFavicon } from "./utilities/icon.js";
      setHexFavicon();
      import { draw } from "./draw.js";
      import { InfoPanel } from "./infoPanel.js";
      import {
        generateTerrain,
        getConfig,
        updateConfig,
      } from "./terrainGeneration.js";
      import {
        hexToPixel,
        pixelToHex,
        getHexVertices,
        getNeighbor,
      } from "./hexUtils.js";
      import {
        BUILDING_TYPES,
        getBuildingType,
        canPlaceBuilding,
      } from "./buildingTypes.js";

      import {
        TRAIN_TYPES,
        TRACK_TYPES,
        getTrackType,
        getTrainType,
      } from "./railwayTypes.js";
      import { SaveGameManager, createSaveLoadButton } from "./savegame.js";
      import { UIManager } from "./ui.js";
      import {
        startBuildingProductionLoop,
        removeResourceFromBuilding,
        updateBuildings,
        spendFromHubs,
        refundToHubs,
      } from "./buildingProduction.js";

      trackGameStarted();

      const canvas = document.getElementById("hexCanvas");
      const ctx = canvas.getContext("2d");

      // Hexagon parameters for FLAT-TOP orientation
      const baseSize = 30;
      let size = baseSize;
      let width = size * 2;
      let height = Math.sqrt(3) * size;

      // Zoom parameters
      // let zoom = 1.0;
      const minZoom = 0.3;
      const maxZoom = 3.0;
      const zoomSpeed = 0.1;

      // Interaction state
      let hoveredElement = null;
      // let currentMode = "place";

      // Terrain types
      const TERRAIN = {
        WATER: { color: "#4a9eff", name: "Water" },
        SAND: { color: "#f4e4a6", name: "Sand" },
        GRASS: { color: "#7bc950", name: "Grass" },
        FOREST: { color: "#2d5016", name: "Forest" },
        MOUNTAIN: { color: "#8b7355", name: "Mountain" },
      };

      // Object types
      const OBJECT_TYPES = {
        TRACK: "track",
        TRAIN: "train",
        BUILDING: "building",
      };

      // Track network graph - maps vertex keys to connected edges
      const trackGraph = {};

      let isDragging = false;
      let dragStartPos = { x: 0, y: 0 };
      let hasDragged = false;
      let lastMousePos = { x: 0, y: 0 };

      const gameState = {
        zoom: 1.0,
        placed_tracks: {},
        placed_buildings: {},
        trains: [],
        nextTrainId: 1,
        camera: { x: 0, y: 0 },
        initialHubPlaced: false,
        terrainConfig: getConfig(),
        powerSupply: 0,
        powerDemand: 0,
      };
      const uiManager = new UIManager(gameState, {
        onModeChange: (mode) => {
          console.log("Mode changed to:", mode);
        },
        onBuildingSelect: (buildingType) => {
          console.log("Building selected:", buildingType);
        },
      });
      const infoPanel = new InfoPanel();
      const map = {}; // not saved because it can just be regenerated.

      // Update size based on zoom
      function updateSizeFromZoom() {
        size = baseSize * gameState.zoom;
        width = size * 2;
        height = Math.sqrt(3) * size;
      }

      // Get all neighbors for debugging
      function getAllNeighbors(col, row) {
        const neighbors = [];
        const sideNames = [
          "lower-right",
          "bottom",
          "lower-left",
          "upper-left",
          "top",
          "upper-right",
        ];
        for (let side = 0; side < 6; side++) {
          const neighbor = getNeighbor(col, row, side);
          neighbors.push({
            side,
            name: sideNames[side],
            col: neighbor.col,
            row: neighbor.row,
          });
        }
        return neighbors;
      }

      // Create a canonical edge key from two hex coordinates
      function createEdgeKey(col1, row1, col2, row2) {
        const a = [col1, row1];
        const b = [col2, row2];
        const [first, second] = [a, b].sort((p, q) => {
          if (p[0] !== q[0]) return p[0] - q[0];
          return p[1] - q[1];
        });
        return `edge_${first[0]}_${first[1]}_${second[0]}_${second[1]}`;
      }

      // Create a vertex key from hex coordinates and vertex index
      function createVertexKey(col, row, vertexIndex) {
        // Use baseSize instead of size to make vertex keys zoom-independent
        const pos = hexToPixel(col, row, size);
        const angles = [0, 60, 120, 180, 240, 300];
        const angleRad = (Math.PI / 180) * angles[vertexIndex];
        // Use baseSize here instead of size - this makes the key independent of zoom
        const x =
          Math.round(
            ((pos.x / size) * baseSize + baseSize * Math.cos(angleRad)) * 100
          ) / 100;
        const y =
          Math.round(
            ((pos.y / size) * baseSize + baseSize * Math.sin(angleRad)) * 100
          ) / 100;
        return `vertex_${x}_${y}`;
      }

      // Get the two vertices for an edge
      function getEdgeVertices(col, row, side) {
        const vertex1Index = side;
        const vertex2Index = (side + 1) % 6;
        return [
          createVertexKey(col, row, vertex1Index),
          createVertexKey(col, row, vertex2Index),
        ];
      }

      // Build track network graph
      function rebuildTrackGraph() {
        // Clear existing graph
        for (let key in trackGraph) {
          delete trackGraph[key];
        }

        // Build graph from all track objects
        for (let edgeKey in gameState.placed_tracks) {
          const obj = gameState.placed_tracks[edgeKey];
          if (obj.type === OBJECT_TYPES.TRACK) {
            // Find which side this edge is on hex1
            let side = -1;
            for (let i = 0; i < 6; i++) {
              const neighbor = getNeighbor(obj.hex1.col, obj.hex1.row, i);
              if (
                neighbor.col === obj.hex2.col &&
                neighbor.row === obj.hex2.row
              ) {
                side = i;
                break;
              }
            }

            if (side !== -1) {
              const [vertex1Key, vertex2Key] = getEdgeVertices(
                obj.hex1.col,
                obj.hex1.row,
                side
              );

              // Add this edge to both vertices' connection lists
              if (!trackGraph[vertex1Key]) trackGraph[vertex1Key] = [];
              if (!trackGraph[vertex2Key]) trackGraph[vertex2Key] = [];

              trackGraph[vertex1Key].push(edgeKey);
              trackGraph[vertex2Key].push(edgeKey);
            }
          }
        }
      }

      // Get connected tracks at a vertex, excluding the current track
      function getConnectedTracks(currentEdgeKey, vertexKey) {
        if (!trackGraph[vertexKey]) return [];
        return trackGraph[vertexKey].filter((key) => key !== currentEdgeKey);
      }

      // Find which vertex the train is at based on its progress
      function getTrainVertex(train) {
        // Find which side this edge is on hex1
        let side = -1;
        for (let i = 0; i < 6; i++) {
          const neighbor = getNeighbor(train.hex1.col, train.hex1.row, i);
          if (
            neighbor.col === train.hex2.col &&
            neighbor.row === train.hex2.row
          ) {
            side = i;
            break;
          }
        }

        if (side === -1) return null;

        const [vertex1Key, vertex2Key] = getEdgeVertices(
          train.hex1.col,
          train.hex1.row,
          side
        );

        // If progress is 0, train is at vertex1; if 1, train is at vertex2
        return train.progress <= 0 ? vertex1Key : vertex2Key;
      }

      // Transition train to a new track segment
      function transitionTrainToNewTrack(train, newEdgeKey) {
        const newTrack = gameState.placed_tracks[newEdgeKey];
        if (!newTrack) return false;

        // Get current vertex the train is at
        const currentVertex = getTrainVertex(train);
        if (!currentVertex) return false;

        // Find which side of newTrack's hex1 this edge is on
        let newSide = -1;
        for (let i = 0; i < 6; i++) {
          const neighbor = getNeighbor(newTrack.hex1.col, newTrack.hex1.row, i);
          if (
            neighbor.col === newTrack.hex2.col &&
            neighbor.row === newTrack.hex2.row
          ) {
            newSide = i;
            break;
          }
        }

        if (newSide === -1) return false;

        const [newVertex1, newVertex2] = getEdgeVertices(
          newTrack.hex1.col,
          newTrack.hex1.row,
          newSide
        );

        // Determine which end of the new track to start from
        if (currentVertex === newVertex1) {
          // Start from vertex1 (progress 0) and go toward vertex2
          train.hex1 = newTrack.hex1;
          train.hex2 = newTrack.hex2;
          train.edgeKey = newEdgeKey;
          train.progress = 0;
          train.direction = 1;
        } else if (currentVertex === newVertex2) {
          // Start from vertex2 (progress 1) and go toward vertex1
          train.hex1 = newTrack.hex1;
          train.hex2 = newTrack.hex2;
          train.edgeKey = newEdgeKey;
          train.progress = 1;
          train.direction = -1;
        } else {
          return false;
        }

        return true;
      }

      // Get or create hex
      function getHex(col, row) {
        const key = `${col},${row}`;
        if (!map[key]) {
          map[key] = { col, row, terrain: generateTerrain(col, row, TERRAIN) };
        }
        return map[key];
      }

      // Distance between two points
      function distance(x1, y1, x2, y2) {
        return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
      }

      // Distance to line segment
      function distanceToLineSegment(px, py, x1, y1, x2, y2) {
        const dx = x2 - x1;
        const dy = y2 - y1;
        const lengthSquared = dx * dx + dy * dy;

        if (lengthSquared === 0) {
          return distance(px, py, x1, y1);
        }

        let t = ((px - x1) * dx + (py - y1) * dy) / lengthSquared;
        t = Math.max(0, Math.min(1, t));

        const closestX = x1 + t * dx;
        const closestY = y1 + t * dy;

        return distance(px, py, closestX, closestY);
      }

      function findHoveredElement(mouseX, mouseY) {
        const worldX = mouseX - gameState.camera.x;
        const worldY = mouseY - gameState.camera.y;

        const hexCoord = pixelToHex(worldX, worldY, size);
        const hexPos = hexToPixel(hexCoord.col, hexCoord.row, size);

        const vertices = getHexVertices(hexPos.x, hexPos.y, size);
        const vertexRadius = 4 * gameState.zoom;

        // Check vertices first
        for (let i = 0; i < vertices.length; i++) {
          const v = vertices[i];
          if (distance(worldX, worldY, v.x, v.y) < vertexRadius) {
            return {
              type: "vertex",
              col: hexCoord.col,
              row: hexCoord.row,
              vertexIndex: i,
              x: v.x,
              y: v.y,
            };
          }
        }

        // Find the CLOSEST edge within threshold, not just the first one
        const edgeRadius = 12 * gameState.zoom;
        let closestEdge = null;
        let closestDist = Infinity;

        for (let i = 0; i < 6; i++) {
          const v1 = vertices[i];
          const v2 = vertices[(i + 1) % 6];

          const dist = distanceToLineSegment(
            worldX,
            worldY,
            v1.x,
            v1.y,
            v2.x,
            v2.y
          );

          if (dist < edgeRadius && dist < closestDist) {
            closestDist = dist;
            const neighbor = getNeighbor(hexCoord.col, hexCoord.row, i);

            closestEdge = {
              type: "edge",
              col: hexCoord.col,
              row: hexCoord.row,
              edgeIndex: i,
              side: i,
              x: (v1.x + v2.x) / 2,
              y: (v1.y + v2.y) / 2,
              edgeKey: createEdgeKey(
                hexCoord.col,
                hexCoord.row,
                neighbor.col,
                neighbor.row
              ),
            };
          }
        }

        if (closestEdge) {
          return closestEdge;
        }

        // Check if inside the hex tile
        if (distance(worldX, worldY, hexPos.x, hexPos.y) < size) {
          return {
            type: "tile",
            col: hexCoord.col,
            row: hexCoord.row,
            x: hexPos.x,
            y: hexPos.y,
          };
        }

        return null;
      } // Get visible hex range
      function getVisibleHexRange() {
        const margin = 3;
        const topLeft = pixelToHex(
          -gameState.camera.x - width * margin,
          -gameState.camera.y - height * margin,
          size
        );
        const bottomRight = pixelToHex(
          -gameState.camera.x + canvas.width + width * margin,
          -gameState.camera.y + canvas.height + height * margin,
          size
        );

        return {
          minCol: topLeft.col - margin,
          maxCol: bottomRight.col + margin,
          minRow: topLeft.row - margin,
          maxRow: bottomRight.row + margin,
        };
      }

      // Initialize visible map
      function initializeVisibleMap() {
        const range = getVisibleHexRange();
        for (let col = range.minCol; col <= range.maxCol; col++) {
          for (let row = range.minRow; row <= range.maxRow; row++) {
            getHex(col, row);
          }
        }
      }

      // Build draw params object
      function getDrawParams() {
        return {
          canvas,
          map: map,
          placed_tracks: gameState.placed_tracks,
          placed_buildings: gameState.placed_buildings,
          trains: gameState.trains,
          camera: gameState.camera,
          hoveredElement,
          size,
          zoom: gameState.zoom,
          TERRAIN,
          OBJECT_TYPES,
          uiManager,
          canPlaceBuilding,
        };
      }

      // Handle element clicked event
      // Main handler - delegates to specific handlers
      function handleClick(element) {
        if (!element) return;

        if (element.type === "tile") {
          handleTileClick(element);
        } else if (element.type === "edge") {
          handleEdgeClick(element);
        }
      }

      // === TILE HANDLING ===

      function handleTileClick(element) {
        logTileDebugInfo(element);

        const mode = uiManager.getMode();

        if (mode === "building") {
          handleBuildingPlacement(element);
        } else if (mode === "remove") {
          console.log(element);
          handleBuildingRemoval(element);
        } else {
        }
      }

      function handleBuildingPlacement(element) {
        const tileKey = `${element.col},${element.row}`;

        // Early validation checks
        if (gameState.placed_buildings[tileKey]) {
          console.log("Tile already has a building");
          return;
        }

        const hex = getHex(element.col, element.row);
        const terrainType = hex.terrain.name.toUpperCase();
        const selectedBuilding = uiManager.getSelectedBuilding();

        if (!canPlaceBuilding(selectedBuilding, terrainType)) {
          console.log("Cannot place", selectedBuilding, "on", terrainType);
          return;
        }

        const buildingDef = getBuildingType(selectedBuilding);

        if (buildingDef.id === "hub" && !gameState.initialHubPlaced) {
          // Allow placement without spending
        } else {
          // Normal cost check
          if (!spendFromHubs(gameState, buildingDef.cost)) {
            console.log("No money haha:", buildingDef.name);
            return;
          }
        }
        playBuildingSound();
        placeBuilding(
          element,
          tileKey,
          selectedBuilding,
          buildingDef,
          terrainType
        );
      }

      function placeBuilding(
        element,
        tileKey,
        buildingType,
        buildingDef,
        terrainType
      ) {
        const building = {
          type: buildingType,
          col: element.col,
          row: element.row,
          placedAt: Date.now(),
          inventory: {
            inputs: {},
            outputs: {},
          },
          productionProgress: 0,
          canRemove: true,
        };

        // Special case for initial hub
        if (!gameState.initialHubPlaced && buildingType === "hub") {
          gameState.initialHubPlaced = true;
          building.inventory.inputs = { wood: 20, grain: 10, ore: 20 };
          building.canRemove = false;
        }

        gameState.placed_buildings[tileKey] = building;

        console.log("BUILDING PLACED", {
          type: buildingDef.name,
          emoji: buildingDef.emoji,
          tileKey,
          terrain: terrainType,
        });
      }

      function logTileDebugInfo(element) {
        const tileKey = `${element.col},${element.row}`;
        const building = gameState.placed_buildings[tileKey];

        if (building) {
          const buildingDef = getBuildingType(building.type);
          infoPanel.showBuildingDetails(building, buildingDef, gameState);

          // Still log to console for debugging
          console.log("ðŸ¢ Building clicked:", {
            type: building.type,
            location: `(${element.col}, ${element.row})`,
            inventory: building.inventory,
            productionProgress: building.productionProgress,
          });
        } else {
          infoPanel.clearBuildingDetails();

          // Original debug info for empty tiles
          console.log("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          console.log("ðŸ” TILE DEBUG INFO");
          console.log("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          console.log(`Clicked Tile: (${element.col}, ${element.row})`);
          console.log(`Column is ${element.col % 2 === 0 ? "EVEN" : "ODD"}`);

          logNeighborInfo(element);
          logVertexReference();
          logEdgeReference();

          console.log("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
        }
      }

      function logNeighborInfo(element) {
        console.log("\nAll Neighbors (in order):");
        const neighbors = getAllNeighbors(element.col, element.row);
        neighbors.forEach((n) => {
          console.log(`  Side ${n.side} (${n.name}): (${n.col}, ${n.row})`);
        });
      }

      function logVertexReference() {
        console.log("\nVertex angles (for reference):");
        console.log("  Vertex 0: 0Â° (right)");
        console.log("  Vertex 1: 60Â° (lower-right)");
        console.log("  Vertex 2: 120Â° (lower-left)");
        console.log("  Vertex 3: 180Â° (left)");
        console.log("  Vertex 4: 240Â° (upper-left)");
        console.log("  Vertex 5: 300Â° (upper-right)");
      }

      function logEdgeReference() {
        console.log("\nEdge mappings:");
        console.log("  Edge 0: between vertices 0-1 (right edge)");
        console.log("  Edge 1: between vertices 1-2 (lower-right edge)");
        console.log("  Edge 2: between vertices 2-3 (lower-left edge)");
        console.log("  Edge 3: between vertices 3-4 (left edge)");
        console.log("  Edge 4: between vertices 4-5 (upper-left edge)");
        console.log("  Edge 5: between vertices 5-0 (upper-right edge)");
      }

      // === EDGE HANDLING ===

      function handleEdgeClick(element) {
        const mode = uiManager.getMode();

        //it is okay to always place a track since it is the only thing that goes on an edge.
        handleTrackPlacement(element);

        switch (mode) {
          case "place":
            handleTrackPlacement(element);
            break;
          case "remove":
            handleTrackRemoval(element);
            break;
          case "train":
            const trainType = uiManager.getSelectedTrainType();
            console.log(trainType);
            handleTrainPlacement(element, trainType);
            break;
        }
      }

      function handleTrackPlacement(element) {
        const edgeKey = element.edgeKey;

        if (gameState.placed_tracks[edgeKey]) {
          return; // Track already exists
        }

        // Get track definition and check cost
        const trackDef = getTrackType("basic_track");

        if (!spendFromHubs(gameState, trackDef.cost)) {
          console.log("Not enough resources to place track:", trackDef.name);
          return;
        }
        playBuildingSound();

        const neighbor = getNeighbor(element.col, element.row, element.side);

        gameState.placed_tracks[edgeKey] = {
          type: OBJECT_TYPES.TRACK,
          hex1: { col: element.col, row: element.row },
          hex2: { col: neighbor.col, row: neighbor.row },
          placedAt: Date.now(),
        };

        console.log("ðŸš‚ TRACK PLACED", {
          edgeKey,
          hex1: `(${element.col}, ${element.row})`,
          hex2: `(${neighbor.col}, ${neighbor.row})`,
          cost: trackDef.cost,
        });

        rebuildTrackGraph();
      }
      function handleBuildingRemoval(element) {
        const tileKey = `${element.col},${element.row}`;

        if (!gameState.placed_buildings[tileKey]) {
          console.log("No building to remove");
          return;
        }

        const building = gameState.placed_buildings[tileKey];
        if (!building.canRemove) {
          console.log("You can't remove your first hub (because)");
          return;
        }
        playRemovalSound();

        const buildingCosts = getBuildingType(
          gameState.placed_buildings[tileKey].type
        ).cost;
        refundToHubs(gameState, buildingCosts);

        delete gameState.placed_buildings[tileKey];

        console.log("ðŸ—‘ï¸ BUILDING REMOVED", {
          type: building.type,
          tileKey,
          col: element.col,
          row: element.row,
        });
      }
      function handleTrackRemoval(element) {
        const edgeKey = element.edgeKey;

        if (!gameState.placed_tracks[edgeKey]) {
          return; // No track to remove
        }

        delete gameState.placed_tracks[edgeKey];
        playRemovalSound();

        refundToHubs(gameState, { ore: 1 });
        console.log("ðŸ—‘ï¸ TRACK REMOVED", { edgeKey });
        rebuildTrackGraph();
      }

      function handleTrainPlacement(element, trainType) {
        const edgeKey = element.edgeKey;

        if (!gameState.placed_tracks[edgeKey]) {
          return; // Can't place train without track
        }

        // Get train definition and check cost
        console.log(trainType);
        const trainDef = getTrainType(trainType);

        if (!spendFromHubs(gameState, trainDef.cost)) {
          console.log("Not enough resources to place train:", trainDef.name);
          return;
        }

        const neighbor = getNeighbor(element.col, element.row, element.side);

        const train = {
          type: trainType,
          id: gameState.nextTrainId++,
          edgeKey: edgeKey,
          hex1: { col: element.col, row: element.row },
          hex2: { col: neighbor.col, row: neighbor.row },
          progress: 0.5,
          cargo: {},
          cargoCapacity: trainDef.cargoCapacity,
          direction: 1,
          speed: trainDef.speed,
          atMaxCargo: false,
          powerDemand:
            trainDef.powerDemand !== undefined ? trainDef.powerDemand : null,
        };

        gameState.trains.push(train);

        console.log("ðŸš† TRAIN PLACED", {
          id: train.id,
          edgeKey,
          hex1: `(${element.col}, ${element.row})`,
          hex2: `(${neighbor.col}, ${neighbor.row})`,
          capacity: trainDef.cargoCapacity,
          speed: trainDef.speed,
          cost: trainDef.cost,
        });
      }
      let invalidly_placed_trains = [];
      // Animate trains
      function updateTrains() {
        let powerUsageFromTrains = 0;
        const powerEfficiency =
          gameState.powerDemand === 0 ||
          gameState.powerSupply >= gameState.powerDemand
            ? 1
            : gameState.powerSupply / gameState.powerDemand;

        gameState.trains.forEach((train) => {
          // Store previous progress to detect midpoint crossing
          if (!gameState.placed_tracks[train.edgeKey]) {
            console.log(
              `Train ${train.id} is on non-existent track, marking for removal`
            );
            invalidly_placed_trains.push(train);
            return; // Skip updating this train
          }
          const prevProgress = train.progress;
          if (train.powerDemand) {
            powerUsageFromTrains += train.powerDemand;
            train.progress += train.speed * train.direction * powerEfficiency;
          } else {
            train.progress += train.speed * train.direction;
          }

          // Check if train crossed the midpoint (0.5)
          const crossedMidpoint =
            (train.direction === 1 &&
              prevProgress < 0.5 &&
              train.progress >= 0.5) ||
            (train.direction === -1 &&
              prevProgress > 0.5 &&
              train.progress <= 0.5);

          if (crossedMidpoint) {
            const hex1Key = `${train.hex1.col},${train.hex1.row}`;
            const hex2Key = `${train.hex2.col},${train.hex2.row}`;

            const buildingOnHex1 = gameState.placed_buildings[hex1Key];
            const buildingOnHex2 = gameState.placed_buildings[hex2Key];

            // Helper function to calculate current cargo amount
            const getCurrentCargoAmount = (train) => {
              let total = 0;
              for (let resource in train.cargo) {
                total += train.cargo[resource];
              }
              return total;
            };

            // Helper function to handle pickup from a building
            const handlePickup = (building) => {
              // console.log("ðŸ” Attempting pickup from building:", {
              //   type: building.type,
              //   hasInventory: !!building.inventory,
              //   inventory: building.inventory,
              // });
              if (!building.inventory || !building.inventory.outputs) return;

              // Pick up all available outputs if there's space
              for (let resourceType in building.inventory.outputs) {
                const available = building.inventory.outputs[resourceType];
                const currentCargo = getCurrentCargoAmount(train);
                const spaceLeft = train.cargoCapacity - currentCargo;

                if (spaceLeft > 0 && available > 0) {
                  const amountToPickup = Math.min(available, spaceLeft);
                  const pickedUp = removeResourceFromBuilding(
                    building,
                    resourceType,
                    amountToPickup
                  );

                  if (!train.cargo[resourceType]) {
                    train.cargo[resourceType] = 0;
                  }
                  train.cargo[resourceType] += pickedUp;

                  // console.log(
                  //   `ðŸš‚ Train ${train.id} picked up ${pickedUp}x ${resourceType}`,
                  //   {
                  //     trainCargo: train.cargo,
                  //     cargoSpace: `${getCurrentCargoAmount(train)}/${
                  //       train.cargoCapacity
                  //     }`,
                  //   }
                  // );
                }
              }
            };

            // Helper function to handle delivery to hub
            // Helper function to handle delivery to hub
            const handleDelivery = (building) => {
              const buildingType = getBuildingType(building.type);

              if (!buildingType) return;

              // Initialize inventory if it doesn't exist
              if (!building.inventory) {
                building.inventory = { inputs: {}, outputs: {} };
              }

              // Deliver to hubs - they accept everything into inputs
              if (buildingType.isHub) {
                for (let resourceType in train.cargo) {
                  const amount = train.cargo[resourceType];

                  if (amount > 0) {
                    // Check capacity
                    const capacity =
                      buildingType.capacity?.[resourceType] || Infinity;
                    const currentAmount =
                      building.inventory.inputs[resourceType] || 0;
                    const spaceLeft = capacity - currentAmount;
                    const amountToDeliver = Math.min(amount, spaceLeft);

                    if (amountToDeliver > 0) {
                      if (!building.inventory.inputs[resourceType]) {
                        building.inventory.inputs[resourceType] = 0;
                      }

                      building.inventory.inputs[resourceType] +=
                        amountToDeliver;

                      // console.log(
                      //   `ðŸ“¦ Train ${train.id} delivered ${amountToDeliver}x ${resourceType} to hub`,
                      //   {
                      //     location: `(${building.col}, ${building.row})`,
                      //     hubInventory: building.inventory.inputs,
                      //   }
                      // );

                      // Remove delivered amount from train
                      train.cargo[resourceType] -= amountToDeliver;
                      if (train.cargo[resourceType] <= 0) {
                        delete train.cargo[resourceType];
                      }
                    }
                  }
                }
              }
              // Deliver to production buildings - only what they consume
              else if (
                buildingType.consumes &&
                buildingType.consumes.length > 0
              ) {
                // Get list of resources this building needs
                const consumedResources = buildingType.consumes.map(
                  (c) => c.type
                );

                for (let resourceType in train.cargo) {
                  // Only deliver if this building consumes this resource
                  if (consumedResources.includes(resourceType)) {
                    const amount = train.cargo[resourceType];

                    if (amount > 0) {
                      // Check capacity
                      const capacity =
                        buildingType.capacity?.[resourceType] || Infinity;
                      const currentAmount =
                        building.inventory.inputs[resourceType] || 0;
                      const spaceLeft = capacity - currentAmount;
                      const amountToDeliver = Math.min(amount, spaceLeft);

                      if (amountToDeliver > 0) {
                        if (!building.inventory.inputs[resourceType]) {
                          building.inventory.inputs[resourceType] = 0;
                        }

                        building.inventory.inputs[resourceType] +=
                          amountToDeliver;

                        // console.log(
                        //   `ðŸ“¦ Train ${train.id} delivered ${amountToDeliver}x ${resourceType} to ${buildingType.name}`,
                        //   {
                        //     location: `(${building.col}, ${building.row})`,
                        //     buildingInventory: building.inventory.inputs,
                        //   }
                        // );

                        // Remove delivered amount from train
                        train.cargo[resourceType] -= amountToDeliver;
                        if (train.cargo[resourceType] <= 0) {
                          delete train.cargo[resourceType];
                        }
                      }
                    }
                  }
                }
              }
            };

            // Process both hexes
            if (buildingOnHex1) {
              handlePickup(buildingOnHex1);
              handleDelivery(buildingOnHex1);
            }

            if (buildingOnHex2) {
              handlePickup(buildingOnHex2);
              handleDelivery(buildingOnHex2);
            }
            train.atMaxCargo =
              getCurrentCargoAmount(train) >= train.cargoCapacity;
          }

          // Check if train reached the end of the track
          if (train.progress >= 1 || train.progress <= 0) {
            // Clamp progress
            train.progress = train.progress >= 1 ? 1 : 0;

            // Get current vertex
            const currentVertex = getTrainVertex(train);

            if (currentVertex) {
              // Get connected tracks at this vertex
              const connectedTracks = getConnectedTracks(
                train.edgeKey,
                currentVertex
              );

              if (connectedTracks.length > 0) {
                // Random walk: pick a random connected track
                const nextTrackKey =
                  connectedTracks[
                    Math.floor(Math.random() * connectedTracks.length)
                  ];

                // Transition to the new track
                const transitioned = transitionTrainToNewTrack(
                  train,
                  nextTrackKey
                );

                if (!transitioned) {
                  // If transition failed, just reverse direction
                  train.direction *= -1;
                }
              } else {
                // Dead end - reverse direction
                train.direction *= -1;
              }
            } else {
              // Fallback: reverse direction
              train.direction *= -1;
            }
          }
        });
        return powerUsageFromTrains; // this is returned because update buildings needs it to finish calculating the full power demand.
      }

      // Resize canvas to fill window
      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        initializeVisibleMap();
      }

      // Handle zoom
      function handleZoom(delta, mouseX, mouseY) {
        const oldZoom = gameState.zoom;

        const zoomChange = delta > 0 ? 1 + zoomSpeed : 1 - zoomSpeed;
        gameState.zoom *= zoomChange;
        gameState.zoom = Math.max(minZoom, Math.min(maxZoom, gameState.zoom));

        if (oldZoom === gameState.zoom) return;

        const worldX = mouseX - gameState.camera.x;
        const worldY = mouseY - gameState.camera.y;

        updateSizeFromZoom();

        gameState.camera.x = mouseX - worldX * (gameState.zoom / oldZoom);
        gameState.camera.y = mouseY - worldY * (gameState.zoom / oldZoom);

        initializeVisibleMap();
      }
      // Save/Load system
      const saveGameManager = new SaveGameManager(gameState);
      window.saveGameManager = saveGameManager;

      const saveLoadBtn = createSaveLoadButton();
      document.body.appendChild(saveLoadBtn);
      saveLoadBtn.addEventListener("click", () => saveGameManager.show());

      // Handle loading games
      window.addEventListener("loadGame", (e) => {
        const state = e.detail;

        // Clear existing state
        for (let key in gameState.placed_tracks)
          delete gameState.placed_tracks[key];
        for (let key in gameState.placed_buildings)
          delete gameState.placed_buildings[key];
        gameState.trains.length = 0;

        // Restore terrain config first
        updateConfig(state.terrainConfig);
        gameState.terrainConfig = state.terrainConfig;

        // Restore game state
        Object.assign(gameState.placed_tracks, state.placed_tracks);
        Object.assign(gameState.placed_buildings, state.placed_buildings);
        gameState.trains.push(...state.trains);
        gameState.nextTrainId = state.nextTrainId;
        gameState.camera = { ...state.camera };
        console.log({ thesavedzoomwas: state.zoom });
        gameState.zoom = state.zoom;
        updateSizeFromZoom();
        gameState.initialHubPlaced = state.initialHubPlaced;
        console.log({ hubstate: gameState.initialHubPlaced });

        // Rebuild derived data
        rebuildTrackGraph();

        // Clear and regenerate map with new terrain config
        for (let key in map) delete map[key];

        initializeVisibleMap();

        console.log("âœ… Game loaded successfully!");
      });

      // Mode button handlers

      // Mouse event handlers
      canvas.addEventListener("mousedown", (e) => {
        isDragging = true;
        hasDragged = false;
        dragStartPos = { x: e.clientX, y: e.clientY };
        lastMousePos = { x: e.clientX, y: e.clientY };
      });

      canvas.addEventListener("mousemove", (e) => {
        if (isDragging) {
          canvas.style.cursor = "grabbing";
          const dx = e.clientX - lastMousePos.x;
          const dy = e.clientY - lastMousePos.y;

          if (
            Math.abs(e.clientX - dragStartPos.x) > 3 ||
            Math.abs(e.clientY - dragStartPos.y) > 3
          ) {
            hasDragged = true;
          }

          gameState.camera.x += dx;
          gameState.camera.y += dy;
          lastMousePos = { x: e.clientX, y: e.clientY };
          initializeVisibleMap();
        } else {
          canvas.style.cursor = "default";
          const newHovered = findHoveredElement(e.clientX, e.clientY);

          if (JSON.stringify(newHovered) !== JSON.stringify(hoveredElement)) {
            hoveredElement = newHovered;
          }
        }
      });

      //TODO: might be nice to tidy this up and add a refund for train removal.
      // I think this re-creation of the array is safe, but it feels risky. (if it becomes a problem could remove the function)
      function removeTrainsByType(e) {
        const { trainType, depotLocation } = e.detail;
        gameState.trains = gameState.trains.filter(
          (train) => train.type !== trainType
        );
      }
      function removeTrain(train_to_remove) {
        console.log(invalidly_placed_trains);
        console.log(train_to_remove);
        gameState.trains = gameState.trains.filter((train) => {
          return train.id !== train_to_remove.id;
        });
      }
      window.addEventListener("removeTrainsByType", (e) => {
        removeTrainsByType(e);
      });

      window.addEventListener("sellResource", (e) => {
        const { resourceType, amount, price } = e.detail;
        spendFromHubs(gameState, { [resourceType]: amount });
        refundToHubs(gameState, { gold: price * amount });
      });

      canvas.addEventListener("click", (e) => {
        if (!hasDragged) {
          const clicked = findHoveredElement(e.clientX, e.clientY);
          handleClick(clicked);
        }
      });

      canvas.addEventListener("mouseup", () => {
        isDragging = false;
      });

      canvas.addEventListener("mouseleave", () => {
        isDragging = false;
        if (hoveredElement) {
          hoveredElement = null;
        }
      });

      window.addEventListener("terrainRegenerate", () => {
        console.log("ðŸ”„ Regenerating world...");

        // Clear the existing map completely
        for (let key in map) {
          delete map[key];
        }

        // Reinitialize visible map with new terrain
        initializeVisibleMap(); ////
        gameState.terrainConfig = getConfig();

        console.log("âœ… World regenerated!");
      });

      canvas.addEventListener(
        "wheel",
        (e) => {
          e.preventDefault();
          handleZoom(-e.deltaY, e.clientX, e.clientY);
        },
        { passive: false }
      );

      // Touch support
      let lastTouchDistance = null;

      canvas.addEventListener("touchstart", (e) => {
        e.preventDefault();

        if (e.touches.length === 2) {
          const dx = e.touches[1].clientX - e.touches[0].clientX;
          const dy = e.touches[1].clientY - e.touches[0].clientY;
          lastTouchDistance = Math.sqrt(dx * dx + dy * dy);
        } else {
          isDragging = true;
          hasDragged = false;
          dragStartPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
          lastMousePos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        }
      });

      canvas.addEventListener("touchmove", (e) => {
        e.preventDefault();

        if (e.touches.length === 2 && lastTouchDistance) {
          const dx = e.touches[1].clientX - e.touches[0].clientX;
          const dy = e.touches[1].clientY - e.touches[0].clientY;
          const distance = Math.sqrt(dx * dx + dy * dy);

          const centerX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
          const centerY = (e.touches[0].clientY + e.touches[1].clientY) / 2;

          const delta = distance - lastTouchDistance;
          handleZoom(delta * 2, centerX, centerY);

          lastTouchDistance = distance;
        } else if (e.touches.length === 1 && isDragging) {
          const dx = e.touches[0].clientX - lastMousePos.x;
          const dy = e.touches[0].clientY - lastMousePos.y;

          if (
            Math.abs(e.touches[0].clientX - dragStartPos.x) > 3 ||
            Math.abs(e.touches[0].clientY - dragStartPos.y) > 3
          ) {
            hasDragged = true;
          }

          gameState.camera.x += dx;
          gameState.camera.y += dy;
          lastMousePos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
          initializeVisibleMap();
        }
      });

      canvas.addEventListener("touchend", (e) => {
        e.preventDefault();

        if (!hasDragged && e.changedTouches.length > 0) {
          const touch = e.changedTouches[0];
          const clicked = findHoveredElement(touch.clientX, touch.clientY);
          handleClick(clicked);
        }

        isDragging = false;
        lastTouchDistance = null;
      });
      canvas.addEventListener("contextmenu", (e) => {
        e.preventDefault();
        if (!hasDragged) {
          const clicked = findHoveredElement(e.clientX, e.clientY);

          if (clicked?.type === "tile") {
            handleBuildingRemoval(clicked);
          } else if (clicked?.type === "edge") {
            handleTrackRemoval(clicked);
          }
        }
      });

      // Initialize
      window.addEventListener("resize", resizeCanvas);
      resizeCanvas();
      welcomeScreen.show();

      // animateTrains();
      let lastUpdateTime = performance.now();
      const FIXED_TIME_STEP = 1000 / 60; // 16.67ms
      let accumulatedTime = 0;

      setInterval(() => {
        const currentTime = performance.now();
        const elapsed = currentTime - lastUpdateTime;
        lastUpdateTime = currentTime;

        if (elapsed < 1000) {
          accumulatedTime += elapsed;
        } else {
          // Tab was inactive - just skip it
          accumulatedTime = 0;
        }

        // Catch up on missed ticks
        while (accumulatedTime >= FIXED_TIME_STEP) {
          const powerUsageFromTrains = updateTrains(
            gameState.trains,
            gameState.placed_buildings
          );
          if (invalidly_placed_trains.length > 0) {
            invalidly_placed_trains.forEach((train) => {
              console.log("removing invalidly placed train");
              removeTrain(train);
              refundToHubs(gameState, getTrainType(train.type).cost);
            });
            invalidly_placed_trains = [];
          }
          updateBuildings(gameState, powerUsageFromTrains);
          accumulatedTime -= FIXED_TIME_STEP;
        }
      }, FIXED_TIME_STEP);
      function render() {
        draw(ctx, getDrawParams());
        infoPanel.update({
          map: map,
          placed_tracks: gameState.placed_tracks,
          placed_buildings: gameState.placed_buildings,
          trains: gameState.trains,
          zoom: gameState.zoom,
          getBuildingType: getBuildingType,
          powerSupply: gameState.powerSupply,
          powerDemand: gameState.powerDemand,
        });
        requestAnimationFrame(render);
      }

      requestAnimationFrame(render);
    </script>
<!--å®¢æœ å¼€å§‹-->
<script src="//g8hh.github.io/static/js/jquery.min.js"></script>
<link rel="stylesheet" href="//g8hh.github.io/static/css/kf.css" type="text/css" media="screen" charset="utf-8">
<script src="//g8hh.github.io/static/js/kf.js"></script>
<!-- å®¢æœ ç»“æŸ -->
<!--ç«™é•¿ç»Ÿè®¡--> 
<div style="display: none">
    <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?028b1b5f659ed138230f4cafd7ad0dfc";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
    </div>
  </body>
</html>
